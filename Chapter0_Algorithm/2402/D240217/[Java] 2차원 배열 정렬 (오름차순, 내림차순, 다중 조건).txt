2차원 배열을 오름차순, 내림차순, 이외에 원하는 조건 등 여러가지 방법으로 정렬 하는 방법을 포스팅 합니다.

2차원 배열을 바로 Arrray.sort()를 통해 정렬하려고 하면 
java.lang.ClassCastException: I cannot be cast to java.lang.Comparable 오류가 발생합니다. 
원인은 비교 기준이 구현되어 있지 않기 때문에 캐스팅에 실패했기 때문이라 
아래와 같이 Comparable,Comparator 인터페이스를 구현하여 정렬기준을 추가해 줘야 합니다. 
2차원배열 뿐만 아니라 객체비교할 때도 동일한 유사하니 참고해주세요


int[][] arr = new int[][]{{5,10},{3,30},{1,50},{4,20},{2,40},{5,60}};
Arrays.sort(arr); //java.lang.ClassCastException: I cannot be cast to java.lang.Comparable



1. Comparator 익명 클래스 구현

int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};

// 1. Comparator 익명 클래스 구현
Arrays.sort(arr, new Comparator<int[]>() {
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
        //return o2[0]-o1[0]; // 첫번째 숫자 기준 내림차순 {5,40}{4,20}{3,50}{2,10}{1,30}
        //return o1[1]-o2[1]; // 두번째 숫자 기준 오름차순 {2,10}{4,20}{1,30}{5,40}{3,50}
        //return o2[1]-o1[1]; // 두번째 숫자 기준 내림차순 {3,50}{5,40}{1,30}{4,20}{2,10}
    }
});

// 다중 조건 
int[][] arr2 = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10},{6,40},{6,50},{6,10},{6,20},{6,30}};

Arrays.sort(arr2, new Comparator<int[]>() { 
    @Override
    public int compare(int[] o1, int[] o2) {
        return o1[0]!=o2[0] ? o1[0]-o2[0] : o1[1]-o2[1]; // 첫번째 기준 오름차순 > 두번째 기준 오름차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,10}{6,20}{6,30}{6,40}{6,50}
        //return o1[0]!=o2[0] ? o1[0]-o2[0] : o2[1]-o1[1]; // 첫번째 기준 오름차순 > 두번째 기준 내림차순  : {1,30}{2,10}{3,50}{4,20}{5,40}{6,50}{6,40}{6,30}{6,20}{6,10}
    }
});





2. Lambda 사용 - Java 8이상

int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};
// 2. Lambda 사용 - Java 8이상
Arrays.sort(arr, (o1, o2) -> {
    return o1[0]-o2[0]; // 첫번째 숫자 기준 오름차순 {1,30}{2,10}{3,50}{4,20}{5,40}
});




3. Comparator.comparing() 사용

int[][] arr = new int[][]{{5,40},{3,50},{1,30},{4,20},{2,10}};
// 3.  Comparator.comparing() 
Arrays.sort(arr, Comparator.comparingInt((int[] o) -> o[0]));            // 첫번째 숫자 기준 오름차순 : {1,30}{2,10}{3,50}{4,20}{5,40}
Arrays.sort(arr, Comparator.comparingInt((int[] o) -> o[0]).reversed()); // 첫번째 숫자 기준 내림차순 : {5,40}{4,20}{3,50}{2,10}{1,30}
Arrays.sort(arr, Comparator.comparingInt((int[] o) -> o[1]));            // 두번째 숫자 기준 오름차순 : {2,10}{4,20}{1,30}{5,40}{3,50}
Arrays.sort(arr, Comparator.comparingInt((int[] o) -> o[1]).reversed()); // 두번째 숫자 기준 내림차순 : {3,50}{5,40}{1,30}{4,20}{2,10}








